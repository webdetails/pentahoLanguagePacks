# Copyright 2008 - 2010 Pentaho Corporation.  All rights reserved.
# This program is free software; you can redistribute it and/or modify it under the 
# terms of the GNU General Public License, version 2 as published by the Free Software 
# Foundation.
#
# You should have received a copy of the GNU General Public License along with this 
# program; if not, you can obtain a copy at http://www.gnu.org/licenses/gpl-2.0.html 
# or from the Free Software Foundation, Inc., 
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.

AbstractRepositoryLifecycleManager.ERROR_0001_STARTUP_NOT_CALLED=Starten muss zuerst aufgerufen werden
MondrianRepositoryLifecycleManager.USER_0001_VER_COMMENT_MONDRIAN=[System] Mondrian-Ordner erstellt
PdiRepositoryLifecycleManager.USER_0001_VER_COMMENT_PDI=[System] PDI-Ordner erstellt
PdiRepositoryLifecycleManager.USER_0002_VER_COMMENT_DATABASES=[System] Datenbanken-Ordner erstellt
PdiRepositoryLifecycleManager.USER_0003_VER_COMMENT_SLAVESERVERS=[System] SlaveServers-Ordner erstellt
PdiRepositoryLifecycleManager.USER_0004_CLUSTERSCHEMAS=[System] clusterSchemas-Ordner erstellt
PdiRepositoryLifecycleManager.USER_0005_PARTITIONSCHEMAS=[System] partitionSchemas-Ordner erstellt
PentahoJcrTemplate.ERROR_0001_ACCESS_DENIED=Zugriff auf diese Daten verweigert
DefaultRepositoryLifecycleManager.USER_0001_VER_COMMENT_PENTAHO_ROOT=[System] Pentaho-Stammorder erstellt
DefaultRepositoryLifecycleManager.USER_0002_VER_COMMENT_TENANT_ROOT=[System] Mandantenstammordner erstellt
DefaultRepositoryLifecycleManager.USER_0003_TENANT_PUBLIC=[System] Öffentlicher Mandantenordner erstellt
DefaultRepositoryLifecycleManager.USER_0004_TENANT_HOME=[System] Mandantenbasisordner erstellt
DefaultRepositoryLifecycleManager.USER_0005_TENANT_ETC=[System] Mandantenordner usw. erstellt
DefaultRepositoryLifecycleManager.USER_0006_USER_HOME=[System] Benutzerbasisordner erstellt
DefaultUnifiedRepositoryWebService.ERROR_0001_NO_IMPL=keine Implementierung von IUnifiedRepository
ExceptionLoggingDecorator.lockException=Fehler beim Sperren von {0}\n\nReferenznummer: {1}
ExceptionLoggingDecorator.transactionException=Transaktionsfehler während {0}\n\nReferenznummer: {1}
ExceptionLoggingDecorator.accessDeniedException=Zugriff verweigert, wenn {0}\n\n Referenznummer: {1}
ExceptionLoggingDecorator.referentialIntegrityException=referenzieller Integritätsfehler während {0}; (Die Datei {1} wird über die Datei(en) {2} referenziert)\n\nReferenznummer: {3}
ExceptionLoggingDecorator.fileExistsException=Fehler &quot;Die Datei besteht bereits&quot; während {0}; der Pfad lautet &quot;{1}&quot;\n\nReferenznummer: {2}
ExceptionLoggingDecorator.malformedNameException=Fehler &quot;Name ist falsch formatiert&quot; während {0}; ungültiger Name: &quot;{1}&quot;\n\nReferenznummer: {2}
ExceptionLoggingDecorator.canUnlockFile=Möglichkeit zur Entsperrung der Datei mit der ID &quot;{0}&quot; wird ermittelt.
ExceptionLoggingDecorator.createFile=Datei mit dem Namen &quot;{0}&quot; wird erstellt.
ExceptionLoggingDecorator.createFolder=Ordner mit dem Namen &quot;{0}&quot; wird erstellt.
ExceptionLoggingDecorator.deleteFile=Datei mit ID &quot;{0}&quot; wird gelöscht.
ExceptionLoggingDecorator.deleteFileAtVersion=Datei mit ID &quot;{0}&quot; und Versionskennung &quot;{1}&quot; wird gelöscht.
ExceptionLoggingDecorator.generalException=Ausnahmefehler während {0}\n\nReferenznummer: {1}
ExceptionLoggingDecorator.getAcl=ACL für Datei mit ID &quot;{0}&quot; wird abgerufen.
ExceptionLoggingDecorator.getChildren=Untergeordnete Elemente für Ordner mit ID &quot;{0}&quot; werden abgerufen.
ExceptionLoggingDecorator.getData=Daten für die Datei mit ID &quot;{0}&quot; werden abgerufen.
ExceptionLoggingDecorator.getDataInBatch=Daten werden für die Dateien abgerufen.
ExceptionLoggingDecorator.getDataAtVersion=Daten für die Datei mit ID &quot;{0}&quot; und Versionskennung &quot;{0}&quot; werden abgerufen.
ExceptionLoggingDecorator.getDeletedFiles=Alle gelöschten Daten werden abgerufen.
ExceptionLoggingDecorator.getDeletedFilesInFolder=Gelöschte Daten im Ordner mit dem Pfad &quot;{0}&quot; werden abgerufen.
ExceptionLoggingDecorator.getEffectiveAces=Gültige ACEs für die Datei mit ID &quot;{0}&quot; werden abgerufen.
ExceptionLoggingDecorator.getFile=Datei mit dem Pfad &quot;{0}&quot; wird abgerufen.
ExceptionLoggingDecorator.getReferrers=Verweise für die Datei mit ID &quot;{0}&quot; werden abgerufen.
ExceptionLoggingDecorator.getTree=Die Struktur mit dem Stammpfad &quot;{0}&quot; wird abgerufen.
ExceptionLoggingDecorator.getFileAtVersion=Datei mit ID &quot;{0}&quot; und Versionskennung &quot;{1}&quot; wird abgerufen.
ExceptionLoggingDecorator.getFileById=Datei mit ID &quot;{0}&quot; wird abgerufen.
ExceptionLoggingDecorator.getVersionSummaries=Versionsverlauf für die Datei mit ID &quot;{0}&quot; wird abgerufen.
ExceptionLoggingDecorator.getVersionSummary=Versionsinformationen für die Datei mit ID &quot;{0}&quot; und Versionskennung &quot;{1}&quot; werden abgerufen.
ExceptionLoggingDecorator.getVersionSummaryInBatch=Versionsinformationen für die Dateien werden abgerufen.
ExceptionLoggingDecorator.hasAccess=Zugang zur Datei mit dem Pfad &quot;{0}&quot; wird ermittelt.
ExceptionLoggingDecorator.lockFile=Datei mit ID &quot;{0}&quot; wird gesperrt.
ExceptionLoggingDecorator.moveFile=Datei mit ID &quot;{0}&quot; wird zum Zielpfad &quot;{1}&quot; verschoben.
ExceptionLoggingDecorator.copyFile=Datei mit ID &quot;{0}&quot; wird zum Zielpfad &quot;{1}&quot; kopiert.
ExceptionLoggingDecorator.referenceNumber=Referenznummer: {0}
ExceptionLoggingDecorator.restoreFileAtVersion=Datei mit Datei-ID &quot;{0}&quot; und Versionskennung &quot;{1}&quot; wird wiederhergestellt.
ExceptionLoggingDecorator.undeleteFile=Datei mit ID &quot;{0}&quot; wird wiederhergestellt.
ExceptionLoggingDecorator.unlockFile=Datei mit ID &quot;{0}&quot; wird freigegeben.
ExceptionLoggingDecorator.updateAcl=ACL für Datei mit ID &quot;{0}&quot; wird aktualisiert.
ExceptionLoggingDecorator.updateFile=Datei mit ID &quot;{0}&quot; wird aktualisiert.
ExceptionLoggingDecorator.getReservedChars=Reservierte Zeichen werden abgerufen.
ExceptionLoggingDecorator.getAvailableLocalesForFile=Verfügbare Gebietsschemas für Datei &quot;{0}&quot; werden abgerufen.
ExceptionLoggingDecorator.getLocalePropertiesForFile=Gebietsschemaeigenschaften für Datei &quot;{0}&quot; werden abgerufen.
ExceptionLoggingDecorator.setLocalePropertiesForFile=Gebietsschemaeigenschaften für Datei &quot;{0}&quot; werden festgelegt.
ExceptionLoggingDecorator.deleteLocalePropertiesForFile=Gebietsschemaeigenschaften für Datei &quot;{0}&quot; werden gelöscht.
FileImporter.WARN_0001_NO_EXT={0} wird übersprungen, da keine Erweiterung für die Datei besteht.
FileImporter.WARN_0002_NO_CONVERTER={0} wird übersprungen, da kein Konverter für die Erweiterung gefunden wurde.
FileImporter.WARN_0003_IOEXCEPTION={0} wird aufgrund einer Ausnahme übersprungen.
FileImporter.WARN_0004_NO_MIME={0} überspringen, da kein MIME-Typ für die Erweiterung gefunden wurde
FileImporter.USER_0001_IMPORT_COUNT={0} von {1} Dateien importiert ({2} ms)
FileImporter.ERROR_0001_ERROR_RETRIEVING_FILES=Fehler beim Abrufen der Dateien
FileImporter.ERROR_0002_ERROR_IMPORTING_FILE=Fehler beim Importieren der Datei {1}: {0}
JackrabbitRepositoryFileAclDao.ERROR_0001_NODE_NOT_FOUND=Knoten mit der ID [{0}] nicht gefunden
JackrabbitRepositoryFileAclDao.ERROR_0002_POLICY=höchstwahrscheinlich, weil readAclById aufgerufen wurde, bevor createAcl aufgerufen wurde
JackrabbitRepositoryFileAclDao.USER_0001_VER_COMMENT_CREATED_ACL=[System] ACL erstellt
JackrabbitRepositoryFileAclDao.USER_0002_VER_COMMENT_UPDATED_ACL=[System] ACL aktualisiert
JcrRepositoryFileDao.ERROR_0001_NO_TRANSFORMER=kein Transformator gefunden
JcrRepositoryFileDao.ERROR_0002_CANNOT_OVERWRITE_FILE_WITH_FOLDER=Datei kann nicht mit Ordner überschrieben werden
JcrRepositoryFileDao.ERROR_0003_ILLEGAL_DEST_PATH=unzulässiger Zielpfad
JcrRepositoryFileDao.ERROR_0004_PARENT_MUST_EXIST=Es muss ein direkter übergeordneter Ordner des Zielpfads bestehen
JcrRepositoryFileDao.ERROR_0005_PARENT_MUST_BE_FOLDER=Das übergeordnete Element des Zielpfads ist kein Ordner
JcrRepositoryFileDao.USER_0001_VER_COMMENT_ADD_FOLDER=[system] hinzugefügter untergeordneter Ordner &quot;{0}&quot; zu {1}
JcrRepositoryFileDao.USER_0002_VER_COMMENT_ADD_FILE=[system] hinzugefügte untergeordnete Datei &quot;{0}&quot; zu {1}
JcrRepositoryFileDao.USER_0003_VER_COMMENT_LOCK_FILE=[system] gesperrte Datei mit ID={0}
JcrRepositoryFileDao.LOCALE_0001_UPDATE_PROPERTIES=Aktualisieren der Eigenschaften des Gebietsschemas für ID={0}
JcrRepositoryFileDao.LOCALE_0002_DELETE_PROPERTIES=Löschen der Eigenschaften des Gebietsschemas für ID={0}
JcrRepositoryFileUtils.ERROR_0001_MISSING_EXT=Dateinamen müssen eine Erweiterung aufweisen
JcrRepositoryFileUtils.USER_0001_VER_COMMENT_UNLOCK_FILE=[system] freigegebene Datei mit ID={0}
JcrRepositoryFileUtils.WARN_0001_NPE_FROM_CR="NPE von Inhaltsrepository abfragen"
XmlAdapter.ERROR_0001_MARSHAL=Fehler beim Marshalling von {0} nach {1}
XmlAdapter.ERROR_0002_UNMARSHAL=Fehler beim Un-Marshalling von {0} nach {1}
DefaultDeleteHelper.ERROR_0001_PATH_NOT_FOUND=ID des übergeordneten Original-Ordners kann nicht bestimmt werden, da der Zielpfad des übergeordneten Ordners nicht vorhanden ist
DefaultDeleteHelper.ERROR_0002_NOT_CLEAN=dies sollte über &quot;Wiederherstellen&quot; oder &quot;Endgültig löschen&quot; bereinigt worden sein
JcrRepositoryFileDao.ERROR_0006_ACCESS_DENIED_DELETE=Zugriff verweigert während die Datei mit ID [ {0} ] gelöscht wird
DefaultUnifiedRepository.ERROR_0001_ACCESS_DENIED_UPDATE_ACL=Zugriff verweigert, während Berechtigungen für die Datei mit ID [ {0} ] hochgeladen werden
AclNodeHelper.ERROR_0001_ROOT_FOLDER_NOT_AVAILABLE=Stammverzeichnis {0} nicht verfügbar. Standard-{1} wird stattdessen verwendet
AclNodeHelper.WARN_0001_REMOVE_ACL_NODE=Entfernen des ACL-Knotens:
AclNodeHelper.WARN_0002_REMOVE_ACL_STORE=Entfernen des ACL-Speichers: {0}
